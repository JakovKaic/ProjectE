#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "app_uart.h"
#include "app_error.h"
#include "nrf.h"
#include "bsp.h"
#include "nrf_uarte.h"
#include "nrfx_uarte.h"

#define HEADER2 0xFF
#define HEADER1 0xFA

static const nrfx_uarte_t uarte0 = NRFX_UARTE_INSTANCE(0);
static uint8_t msg_buff[256];
static uint16_t msg_index = 0;
static uint16_t payload_len = 0;
static uint8_t byte;

/*
    PRETVORI PODATAK IZ BIG ENDIANA U FLOAT
*/
static float read_float_be(const uint8_t *p)
{
    uint32_t tmp =
        ((uint32_t)p[0] << 24) |
        ((uint32_t)p[1] << 16) |
        ((uint32_t)p[2] << 8)  |
        ((uint32_t)p[3]);

    float f;
    memcpy(&f, &tmp, sizeof(float));
    return f;
}

/*
    TRAÅ½I HEADER ZA AKCELERACIJU I ISPISUJ PODATKE AKCELERACIJE U TERMINAL
*/
void parse_mtdata2(uint8_t *payload, uint16_t length)
{
    uint16_t i = 0;

    while (i < length)
    {
        uint16_t data_id = (payload[i] << 8) | payload[i + 1];
        uint8_t data_len = payload[i + 2];
        i += 3;

        if (data_id == 0x1020)  // AKCELERACIJA
        {
            float ax = read_float_be(&payload[i + 0]);
            float ay = read_float_be(&payload[i + 4]);
            float az = read_float_be(&payload[i + 8]);

            char out[64];
            int len = snprintf(out, sizeof(out),
                               "ACC: %.3f %.3f %.3f\r\n",
                               ax, ay, az);

            nrfx_uarte_tx(&uarte0, (uint8_t *)out, len);
        }

        i += data_len;
    }
}

/*
    RESTARTAJ INDEX I PAYLOAD
*/

void flush()
{
  msg_index = 0;
  payload_len = 0;
}

/* 
    OBRADI BAJT PRIMLJEN PREKO UARTE-A I SPREMI GA U BUFFERE
*/

void process_byte()
{

  msg_buff[msg_index++] = byte;

  if(msg_index == 1 && byte != HEADER1)

    {
      flush();
    }

  else if (msg_index == 2 && byte != HEADER2)
    {
      flush();
    }

  else if(msg_index == 4)

    {
      payload_len = byte;
    }

  else if (msg_index == payload_len + 5)
    {
      if (msg_buff[2] == 0x36) // MTData2
      {
        parse_mtdata2(&msg_buff[4], payload_len);
      }

      flush();
    }

}

/*
    UARTE INTERRUPT HANDLER FUNKCIJA
*/

void uarte_event_handler(nrfx_uarte_event_t const *p_event, void *p_context)

{ 
  if(p_event->type == NRFX_UARTE_EVT_RX_DONE)
  {

    process_byte();  
    nrfx_uarte_rx(&uarte0, &byte, 1);   

  }

  else if (p_event -> type == NRFX_UARTE_EVT_TX_DONE)
  {
    nrfx_uarte_rx(&uarte0, &byte, 1);
  }

  else if(p_event->type == NRFX_UARTE_EVT_ERROR)
  {
  }

}



/*
    KONFIGURACIJA UARTE-A I INICIJALIZACIJA
*/

void uarte0_config(void)
{
  nrfx_uarte_config_t config = NRFX_UARTE_DEFAULT_CONFIG;
  config.pselrxd = RX_PIN_NUMBER;
  config.pseltxd = TX_PIN_NUMBER;
  config.hwfc = NRF_UARTE_HWFC_DISABLED;
  config.baudrate = NRF_UARTE_BAUDRATE_460800;

  nrfx_err_t err = nrfx_uarte_init(&uarte0, &config, uarte_event_handler);
  APP_ERROR_CHECK(err);

  err = nrfx_uarte_rx(&uarte0, &byte, sizeof(byte)); //pokreni prijam prvog bajta
  APP_ERROR_CHECK(err);
}

int main(void)
{
    uarte0_config();
    while (true)
    {
       __WFE();
    }

}
